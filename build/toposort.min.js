!function(e,n){"function"==typeof define&&define.amd?define("Toposort",["exports"],n):"undefined"!=typeof exports?n(exports):(n(n={}),e.Toposort=n)}("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:this,function(e){"use strict";function h(e,n){var t,r,o,a,i="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(i)return r=!(t=!0),{s:function(){i=i.call(e)},n:function(){var e=i.next();return t=e.done,e},e:function(e){r=!0,o=e},f:function(){try{t||null==i.return||i.return()}finally{if(r)throw o}}};if(Array.isArray(e)||(i=function(e,n){var t;if(e)return"string"==typeof e?f(e,n):"Map"===(t="Object"===(t=Object.prototype.toString.call(e).slice(8,-1))&&e.constructor?e.constructor.name:t)||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?f(e,n):void 0}(e))||n&&e&&"number"==typeof e.length)return i&&(e=i),a=0,{s:n=function(){},n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:n};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function f(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,r=new Array(n);t<n;t++)r[t]=e[t];return r}function o(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function a(e,n,t){n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var n=function(){function e(){if(!(this instanceof e))throw new TypeError("Cannot call a class as a function");a(this,"edges",[]),a(this,"Toposort",e)}var n,t,r;return n=e,(t=[{key:"add",value:function(e,n){if("string"!=typeof e||!e)throw new TypeError("Dependent name must be given as a not empty string");if(0<(n=Array.isArray(n)?n:[n]).length){var t,r=h(n);try{for(r.s();!(t=r.n()).done;){var o=t.value;if("string"!=typeof o||!o)throw new TypeError("Dependency name must be given as a not empty string");this.edges.push([e,o])}}catch(e){r.e(e)}finally{r.f()}}else this.edges.push([e]);return this}},{key:"sort",value:function(){var e,l=this,u=[],n=h(this.edges);try{for(n.s();!(e=n.n()).done;){var t,r=h(e.value);try{for(r.s();!(t=r.n()).done;){var o=t.value;-1===u.indexOf(o)&&u.push(o)}}catch(e){r.e(e)}finally{r.f()}}}catch(e){n.e(e)}finally{n.f()}for(var s=u.length,c=new Array(u.length),a=function e(n,t){if(0!==t.length&&-1!==t.indexOf(n))throw new Error("Cyclic dependency found. ".concat(n," is dependent of itself.\nDependency chain: ").concat(t.join(" -> ")," => ").concat(n));var r=u.indexOf(n);if(-1!==r){var o,a=!1,i=(u[r]=!1,h(l.edges));try{for(i.s();!(o=i.n()).done;){var f=o.value;f[0]===n&&(a=a||t.concat([n]),e(f[1],a))}}catch(e){i.e(e)}finally{i.f()}c[--s]=n}},i=0;i<u.length;i++){var f=u[i];if(!1!==f){u[i]=!1;var d,y=h(this.edges);try{for(y.s();!(d=y.n()).done;){var p=d.value;p[0]===f&&a(p[1],[f])}}catch(e){y.e(e)}finally{y.f()}c[--s]=f}}return c}},{key:"clear",value:function(){return this.edges=[],this}}])&&o(n.prototype,t),r&&o(n,r),Object.defineProperty(n,"prototype",{writable:!1}),e}();e.default=n,module.exports=exports.default});